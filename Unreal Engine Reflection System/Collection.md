# Collection

In the generation section, various code snippets for different types were inserted to facilitate the setup of collection and registration. The objective in this section is to delve into how type information is gathered through C++ Static automatic registration. The code generated by Unreal UHT, with its metadata of type information, is distributed across multiple files and different DLL modules. To streamline this information and ensure orderly registration during the engine's initialization, Unreal employs a Static Automatic Registration system. This system registers statically allocated objects and links them in a systematic manner, with Modules playing a pivotal role in organizing the engine's structure. Each module has its own script configuration, and at a higher level, the game module depends on essential lower-level modules like Core Module and CoreUObject.

The C++ standard doesn't explicitly dictate the order of initialization for global static variables across different compilation units, leaving the implementation to the compiler's discretion. Given the unreliable nature of static order, avoiding reliance on this determination is considered the optimal solution. However, before we proceed to register the reflected objects for the engine, a crucial step involves statically collecting information for each DLL module. This static collection phase can be envisioned as the pre-registration phase.

### Static Collection

The namespace UECodeGen_Private encapsulates static data structures responsible for collecting type information and defining essential helper functions like constructors required for registration. The information collection is initiated by macros observed in the generation phase. A brief recap and additional context are provided below.

 `IMPLEMENT_CLASS_NO_AUTO_REGISTRATION`

This macro implements "GetPrivateStaticClass" and the registration info but defers actual class registration while declaring the registration info.

The crucial distinction lies in understanding Inner and Outer Singletons:

- **Inner Singleton:** Holds the reflected object filled with actual type information.
- **Outer Singleton:** Holds the reference to a skeleton of the reflected object.

Taking UClass as an example, it is statically set up with the Inner Singleton first a pointer to the pre-initialized Object with null pointers. During registration, when `StaticClass()` is invoked, the data is filled, and UClass is a special case where the Inner Singleton is invoked first during deferred registration. This may seem surprising, as UClass is instantiated for a UObject during pre-registration, but its purpose becomes clearer later. The struct below is the type passed around, holding key type pointers.

```cpp
/**  
 * Structure that represents the registration information for a given class, structure, or enumeration */template <typename T, typename V>  
struct TRegistrationInfo  
{  
    using TType = T;  
    using TVersion = V;  
  
    TType* InnerSingleton = nullptr;  
    TType* OuterSingleton = nullptr;  
    TVersion ReloadVersionInfo;  
};
```

Additionally, in some cases, we could have base native objects like UObject, UStruct, UScript, UModel, and more. 

In such cases, these objects are also reflected. Upon examining the source code, you will come across the macro `IMPLEMENT_CORE_INTRINSIC_CLASS`, which nests down into `IMPLEMENT_INTRINSIC_CLASS`. Notably, these objects lack an associated generated.h or generated.cpp files.

```cpp
#define IMPLEMENT_INTRINSIC_CLASS(TClass, TRequiredAPI, TSuperClass, TSuperRequiredAPI, TPackage, InitCode) \  
    TRequiredAPI UClass* Z_Construct_UClass_##TClass(); \  
    extern FClassRegistrationInfo Z_Registration_Info_UClass_##TClass; \  
    struct Z_Construct_UClass_##TClass##_Statics \  
    { \  
       static UClass* Construct() \  
       { \  
          extern TSuperRequiredAPI UClass* Z_Construct_UClass_##TSuperClass(); \  
          UClass* SuperClass = Z_Construct_UClass_##TSuperClass(); \  
          UClass* Class = TClass::StaticClass(); \  
          UObjectForceRegistration(Class); \  
          check(Class->GetSuperClass() == SuperClass); \  
          InitCode \  
          Class->StaticLink(); \  
          return Class; \  
       } \  
    }; \  
    UClass* Z_Construct_UClass_##TClass() \  
    { \  
       if (!Z_Registration_Info_UClass_##TClass.OuterSingleton) \  
       { \  
          Z_Registration_Info_UClass_##TClass.OuterSingleton = Z_Construct_UClass_##TClass##_Statics::Construct();\  
       } \  
       check(Z_Registration_Info_UClass_##TClass.OuterSingleton->GetClass()); \  
       return Z_Registration_Info_UClass_##TClass.OuterSingleton; \  
    } \
    IMPLEMENT_CLASS(TClass, 0)
```

Here Outer Singleton is defined. `IMPLEMENT_CLASS(TClass, 0)`  is the macro that defines the inner singleton during registration for a Native Object.

Question:

"Why do we need to delay registration instead of just running all this registration stuff instead of directly in the static call back?"

According to Dazhao, 

*"There are about 1,500 classes in UE4. If more than 1,500 classes are collected and registered during the static initialization phase, then the main function must wait for a while before it can start executing. The performance is that the user double-clicked the program, but there was no response. It took a while before the window opened. Therefore, doing as little as possible in the static initialization callback is to speed up the program startup as quickly as possible. When the window is displayed and the data in the array structure is already there, we can use our tricks, whether it is multi-threading or delay, to greatly improve the program running experience."*

For the following sections I've provided a SVG diagram showing the collection for each type. The diagrams will give an visual overview of all the generated code and how it's passed around before it's registered. 

### UClass & UFunction Collection

![[Unreal Engine Reflection System/Reflection Diagrams/UClassCollectionDiagram.svg]](https://github.com/staticJPL/Unreal-Engine-Documentation/blob/b25a89365da6488452f86647f52b88fbf9c7cfe9/Unreal%20Engine%20Reflection%20System/Reflection%20Diagrams/UClassCollectionDiagram.svg)

###### Static Collection Phase

*UClass*

1. UClass Struct Z_Construct statics are generated by UHT and inserted.
2. Dependent singletons of UClass collect function pointer reference names used for construction by UECodeGen_Private.
3. Class_MetaDataParams are collected for Blueprint information.
4. NewProp_Health is an example of a member property that collects a Property Pointer.
5. StaticCPPClassInfo defines whether the class is abstract or not, used for UClass flags.
6. ClassParams collect the information from 1-5.
7. ClassParams are passed with the OuterSingleton to UECodeGen_Private::ConstructUClass.

*UFunction*

1. UFunction Struct Z_Construct statics are generated by UHT and inserted.
2. Implementable, Native, and Callable FuncParameters are collected, holding the string literal name of each function. Z_Construct references the UClass it belongs to. Additionally, Z_Construct Func Statics are defined.
3. Implementable, Native, and Callable are passed into UECodeGen_Private::ConstructUFunction, along with the Function Pointer and the Function Parameters collected previously.
4. FuncInfo is populated with the result of UECodeGen_Private::ConstructUFunction.
5. FuncInfo is passed together with the ClassParams struct.

###### Static Pre-Registration

*UClass*

1. Z_Struct_CompiledInDeferFile is declared with a static FClassRegisterCompiledInfo as ClassInfo[].
2. The IMPLEMENT_CLASS_NO_AUTO_REGISTRATION macro inserts the templated Registration_Info_UClass and declares GetPrivateStaticClass().
3. Z_Construct_UClass_* is passed together with Registration_Info_UClass_* into ClassInfo.
4. ClassInfo[] is collected for the Registration Phase inside FRegisterCompiledInInfo Z_CompiledInDeferFile to be later sent off to FClassDeferredRegistry with the forward args when the struct constructor is called.

#### Summary

From observation, the static collection serves the purpose of supplying necessary type information where the order of loading doesn't matter. UECodeGen_Private is employed to set up and construct the OuterSingleton, with the intention of allocating it in memory and setting the skeleton with the value of the Inner Singleton. This occurs during registration with a call to StaticClass(), invoking GetPrivateStaticClassBody. It's important to note that many function pointers are passed around to bypass the C++ constructor and to construct these type objects using lazy initialization. The workaround with function pointers involves wrapping the construction of the Reflection Object at runtime (e.g., in Blueprints or when dragging actors into the scene). Classes contain properties and functions along with their parameters. It's worth noting that the construction of UFunction, from my understanding must occur before the construction of UClass.

```cpp
void ConstructUClass(UClass*& OutClass, const FClassParams& Params)  
{  
if (OutClass && (OutClass->ClassFlags & CLASS_Constructed))  
{       
	return;  
}  
for (UObject* (*const *SingletonFunc)() = Params.DependencySingletonFuncArray, *(*const *SingletonFuncEnd)() = SingletonFunc + Params.NumDependencySingletons; SingletonFunc != SingletonFuncEnd; ++SingletonFunc)  
{      
	 (*SingletonFunc)();  
}  
UClass* NewClass = Params.ClassNoRegisterFunc();  
OutClass = NewClass;
```

```Params.ClassNoRegisterFunc();```

```cpp
struct FClassFunctionLinkInfo  
{  
    UFunction* (*CreateFuncPtr)();  
    const char* FuncNameUTF8;  
};
```

Since both CreateFuncPtr and Params.ClassNoRegisterFunc() return a defined UClass Object and prerequisite UFunction*, one might wonder why not use these pointers directly? The answer lies in the uncertainty of construction order, which introduces complexity in managing type dependencies. This complexity arises from the need to ensure that all types are defined in the correct order before initiating the construction of the main type. While one could attempt to establish a build dependency hierarchy to meticulously define and ensure the construction of each object's preceding types, this approach becomes impractical at scale.

Instead, the use of lazy evaluation in conjunction with the singleton pattern offers a solution to process these objects. If an object is not constructed, it is built and returned; if it has already been constructed, it is simply returned. The Outer Singleton and Inner Singleton pattern facilitates the management of object creation and dependencies as they are needed, providing a more flexible and scalable solution.

### Uinterface Collection

![[Reflection Diagrams/UInterfaceCollectionDiagram.svg]](https://github.com/staticJPL/Unreal-Engine-Documentation/blob/b25a89365da6488452f86647f52b88fbf9c7cfe9/Unreal%20Engine%20Reflection%20System/Reflection%20Diagrams/UInterfaceCollectionDiagram.svg)
###### Static Collection Phase

1. UInterface Struct Z_Construct Static Declarations are generated by UHT and inserted.
2. UInterface Dependent Singletons collect function pointers for Z_Construct_UClass_UInterface and the Package (Owner).
3. Class_MetaDataParams are collected for Blueprints.
4. StaticCPPClassTypeInfo is set to Abstract for class flags.
5. FuncInfo data is collected after the construction of FuncParams.
6. ClassParams collect data from steps 1-5.
7. ClassParams are passed with the OuterSingleton to UECodeGen_Private::ConstructUClass.
###### Static Pre-Registration

1. Z_Struct_CompiledInDeferFile is declared with a static FClassRegisterCompiledInfo as ClassInfo[].
2. IMPELEMENT_CLASS_NO_AUTO_REGISTRATION macro inserts the templated .Registration_Info_UClass and declares GetPrivateStaticClass().
3. Z_Construct_UClass_* is passed together with Registration_Info_UClass_* into ClassInfo.
4. ClassInfo[] is collected for the Registration Phase inside FRegisterCompiledInInfo Z_CompiledInDeferFile to be later sent off to FClassDeferredRegistry with the forward args when the struct constructor is called.
#### Summary

Recall that ordinary classes should inherit from UObject; UInterface is a special class that is still stored in UClass. As seen in the collection and pre-registration phase, it follows the same construction path as UClass.

### UStruct UEnum & Property Collection

UStruct is our aggregate type, similar to regular C++, where we can hold different types and create instances with a specific memory layout. 

Let's briefly examine the code to understand how aggregated types, represented by FField, becomes FProperties as the common wrapper for UnrealScriptType.
#### Properties (FField,FVariant,TProperty,FProperty)

Inside UECodeGenPrivate 

```cpp
enum class EPropertyGenFlags : uint8  
{  
    None              = 0x00,  
  
    // First 6 bits are the property type  
    Byte              = 0x00,  
    Int8              = 0x01,  
    Int16             = 0x02,  
    Int               = 0x03,  
    Int64             = 0x04,  
    UInt16            = 0x05,  
    UInt32            = 0x06,  
    UInt64            = 0x07,  
    //                = 0x08,  
    //                = 0x09,    Float             = 0x0A,  
    Double            = 0x0B,  
    Bool              = 0x0C,  
    SoftClass         = 0x0D,  
    WeakObject        = 0x0E,  
    LazyObject        = 0x0F,  
    SoftObject        = 0x10,  
    Class             = 0x11,  
    Object            = 0x12,  
    Interface         = 0x13,  
    Name              = 0x14,  
    Str               = 0x15,  
    Array             = 0x16,  
    Map               = 0x17,  
    Set               = 0x18,  
    Struct            = 0x19,  
    Delegate          = 0x1A,  
    InlineMulticastDelegate = 0x1B,  
    SparseMulticastDelegate = 0x1C,  
    Text              = 0x1D,  
    Enum              = 0x1E,  
    FieldPath         = 0x1F,  
    LargeWorldCoordinatesReal = 0x20,  
  
    // Property-specific flags  
    NativeBool        = 0x40,  
    ObjectPtr         = 0x40,  
  
};
```

EPropertyGenFlags is used as a template type parameter. In the Unreal Engine code under UObjectGlobals.h you'll find several structs.

```cpp
// We don't want to use actual inheritance because we want to construct aggregated compile-time tables of these things.  
struct FPropertyParamsBase  
{  
    const char*    NameUTF8;  
    const char*       RepNotifyFuncUTF8;  
    EPropertyFlags    PropertyFlags;  
    EPropertyGenFlags Flags;  
    EObjectFlags   ObjectFlags;  
    SetterFuncPtr  SetterFunc;  
    GetterFuncPtr  GetterFunc;  
    uint16         ArrayDim;  
};
```

```cpp
struct FPropertyParamsBaseWithOffset // : FPropertyParamsBase  
{  
    const char*    NameUTF8;  
    const char*       RepNotifyFuncUTF8;  
    EPropertyFlags    PropertyFlags;  
    EPropertyGenFlags Flags;  
    EObjectFlags   ObjectFlags;  
    SetterFuncPtr  SetterFunc;  
    GetterFuncPtr  GetterFunc;  
    uint16         ArrayDim;  
    uint16         Offset;  
};
```


Additionally, if you delve deeper, you'll discover more struct parameters defined, such as FGeneric, FByte, FBool, FObject, FInterface, and FStruct, labeled as "ParamsBase." It's important to note that these are not the same as the parameter structs defined in UECodeGen_Private; the other structs hold those types which are then passed into ConstructFProperties.

Starting with ConstructUScriptStruct

```cpp
void ConstructUScriptStruct(UScriptStruct*& OutStruct, const FStructParams& Params)  
{  UObject*                      (*OuterFunc)()     = Params.OuterFunc;  
   UScriptStruct*                (*SuperFunc)()     = Params.SuperFunc;  
   UScriptStruct::ICppStructOps* (*StructOpsFunc)() = (UScriptStruct::ICppStructOps* (*)())Params.StructOpsFunc;  
   UObject*                      Outer     = OuterFunc     ? OuterFunc() : nullptr; 
   UScriptStruct*                Super     = SuperFunc     ? SuperFunc() : nullptr; 
   UScriptStruct::ICppStructOps* StructOps = StructOpsFunc ? StructOpsFunc() : nullptr;  

   if (OutStruct)  
   {         
		return;  
   }  
   UScriptStruct* NewStruct = new(EC_InternalUseOnlyConstructor, Outer, UTF8_TO_TCHAR(Params.NameUTF8), Params.ObjectFlags) UScriptStruct(FObjectInitializer(), Super, StructOps, (EStructFlags)Params.StructFlags, Params.SizeOf, Params.AlignOf);  
   OutStruct = NewStruct;  

   ConstructFProperties(NewStruct, Params.PropertyArray, Params.NumProperties);  

   NewStruct->StaticLink();  

#if WITH_METADATA  
   AddMetaData(NewStruct, Params.MetaDataArray, Params.NumMetaData);  
#endif  
}
```

You will encounter the call to ConstructFProperties, where a freshly allocated UScriptStruct is passed to be populated with the aggregate data. The Outer can be passed as a Class or NewFunction. In our example, we've defined a "Score" member Property, which gets translated from UHT as:

```c
static const UECodeGen_Private::FFloatPropertyParams NewProp_Score;
```

However, it's collected by the PropPointer[] array

```cpp
const UECodeGen_Private::FPropertyParamsBase* const Z_Construct_UScriptStruct_FMyStruct_Statics::PropPointers[] = {  
    (const UECodeGen_Private::FPropertyParamsBase*)&Z_Construct_UScriptStruct_FMyStruct_Statics::NewProp_Score,  
};
```

Its return type is `FPropertyParamsBase*`. However, we've collected `FFloatPropertyParams`. So how does this work? Turns out there are many other defined types, as illustrated here:

```c
// These property types don't add new any construction parameters to their base property  
typedef FGenericPropertyParams FInt8PropertyParams;
typedef FGenericPropertyParams FInt16PropertyParams;  
typedef FGenericPropertyParams FIntPropertyParams;  
typedef FGenericPropertyParams FInt64PropertyParams;  
typedef FGenericPropertyParams FUInt16PropertyParams;  
typedef FGenericPropertyParams FUInt32PropertyParams;  
typedef FGenericPropertyParams FUInt64PropertyParams;  
typedef FGenericPropertyParams FFloatPropertyParams;  
typedef FGenericPropertyParams FDoublePropertyParams;  
typedef FGenericPropertyParams FLargeWorldCoordinatesRealPropertyParams;  
typedef FGenericPropertyParams FNamePropertyParams;  
typedef FGenericPropertyParams FStrPropertyParams;  
typedef FGenericPropertyParams FSetPropertyParams;  
typedef FGenericPropertyParams FTextPropertyParams;  
typedef FObjectPropertyParams  FWeakObjectPropertyParams;  
typedef FObjectPropertyParams  FLazyObjectPropertyParams;  
typedef FObjectPropertyParams  FObjectPtrPropertyParams;  
typedef FClassPropertyParams   FClassPtrPropertyParams;  
typedef FObjectPropertyParams  FSoftObjectPropertyParams;
```

FFloatPropertyParams is really a FGenericPropertyParams and the GenericPropertyParam has a layout like this,

```cpp
struct FGenericPropertyParams // : FPropertyParamsBaseWithOffset  
{  
   const char*      NameUTF8;  
   const char*       RepNotifyFuncUTF8;  
   EPropertyFlags    PropertyFlags;  
   EPropertyGenFlags Flags;  
   EObjectFlags     ObjectFlags;  
   SetterFuncPtr  SetterFunc;  
   GetterFuncPtr  GetterFunc;  
   uint16           ArrayDim;  
   uint16           Offset;  
#if WITH_METADATA  
   uint16                              NumMetaData;  
   const FMetaDataPairParam*           MetaDataArray;  
#endif  
};
```

Now it gets interesting. The first realization is that the `FGenericPropertyParams` and the `FPropertyParamsBase` have the same layout in memory until the `uint16 Offset`!

My best guess from reading the source code is that it allows the usage of an `FField` object to be used with the `FProperty` construction system. It appears to allow some sort of memory optimizations and more control through templated polymorphism. Digging further into the `FStructParams` array, `FPropertyParamsBase*` loops through all of the `PropertyTypes` needed for construction.

```cpp
void ConstructFProperties(UObject* Outer, const FPropertyParamsBase* const* PropertyArray, int32 NumProperties)  
{  
    // Move pointer to the end, because we'll iterate backwards over the properties  
    PropertyArray += NumProperties;  
    while (NumProperties)  
    {      
     ConstructFProperty(Outer, PropertyArray, NumProperties);  
    }}
```

`ConstructFProperty` runs a recursive function call for all the properties using the flags inserted by UHT alongside any `EPropertyGenFlags` to insert the correct template information.

```cpp
void ConstructFProperty(FFieldVariant Outer, const FPropertyParamsBase* const*& PropertyArray, int32& NumProperties)  
{  
const FPropertyParamsBase* PropBase = *--PropertyArray;  

uint32 ReadMore = 0;  

FProperty* NewProp = nullptr;  
switch (PropBase->Flags & PropertyTypeMask)  
{       default:  
   {  
	  // Unsupported property type  
	  check(false);  
   }  
   case EPropertyGenFlags::Byte:  
   {  
	  NewProp = NewFProperty<FByteProperty, FBytePropertyParams>(Outer, *PropBase);  
   }       break;  

   case EPropertyGenFlags::Int8:  
   {  
	  NewProp = NewFProperty<FInt8Property, FInt8PropertyParams>(Outer, *PropBase);  
   }       break;  

   case EPropertyGenFlags::Int16:  
   {  
	  NewProp = NewFProperty<FInt16Property, FInt16PropertyParams>(Outer, *PropBase);  
   }       break;  

   case EPropertyGenFlags::Int:  
   {  
	  NewProp = NewFProperty<FIntProperty, FIntPropertyParams>(Outer, *PropBase);  
   }       break;  

 ... // Lots of other Case statements code here from engine source.

   case EPropertyGenFlags::Enum:  
   {  
	  NewProp = NewFProperty<FEnumProperty, FEnumPropertyParams>(Outer, *PropBase);  

	  // Next property is the underlying integer property  
	  ReadMore = 1;  
   }       break;  
  ... // Code here 
}  
--NumProperties;  

for (; ReadMore; --ReadMore)  
{      
	ConstructFProperty(NewProp, PropertyArray, NumProperties);  
}}
```

This is where the chain of reflected atomic types is constructed, some of which are compared with CPP native types. Notice how the `Prop` is finally cast to its actual parameter type based on the flags passed from UHT. `Outer` is important because it can be an `FField` or `UObject` type. `FFieldVariant` is a wrapper class used to initialize an instance as either one inside its constructor.

```cpp
/**  
 * Special container that can hold either UObject or FField. * Exposes common interface of FFields and UObjects for easier transition from UProperties to FProperties. * DO NOT ABUSE. IDEALLY THIS SHOULD ONLY BE FFIELD INTERNAL STRUCTURE FOR HOLDING A POINTER TO THE OWNER OF AN FFIELD. */

class FFieldVariant  
{  
    union FFieldObjectUnion  
    {  
       FField* Field;  
       UObject* Object;  
    } Container;  
  
    static constexpr uintptr_t UObjectMask = 0x1;  
  
public:  
  
    FFieldVariant()  
    {       
	    Container.Field = nullptr;  
    }  
    
    FFieldVariant(const FField* InField)  
    {
	    Container.Field = const_cast<FField*>(InField);
	    check(!IsUObject());  
    }
    ...
```

```cpp
template <typename PropertyType, typename PropertyParamsType>  
PropertyType* NewFProperty(FFieldVariant Outer, const FPropertyParamsBase& PropBase)  
{       
  const PropertyParamsType& Prop = (const PropertyParamsType&)PropBase;  
  PropertyType* NewProp = nullptr;
	
   if (Prop.SetterFunc || Prop.GetterFunc)  
   { 
	   NewProp = new TPropertyWithSetterAndGetter<PropertyType>(Outer, Prop);  
   }
   else  
   {  
	  NewProp = new PropertyType(Outer, Prop);  
   }  
   // Meta data is here in actual source
   return NewProp;  
}
```

The first template parameter `PropertyType` references the actual native type defined inside UnrealType.h. The second template parameter is used to set the memory layout back to the actual type that was collected from the generated code. In our UStruct of the Reflection Test project, our `Score` value was defined as a floating-point type.

```c
case EPropertyGenFlags::Float:  
{  
    NewProp = NewFProperty<FFloatProperty, FFloatPropertyParams>(Outer, *PropBase);  
}
```

Digging into FFloatProperty, the class contains the `DECLARE_FIELD` macro.

```cpp
#define DECLARE_FIELD_API(TClass, TSuperClass, TStaticFlags, TRequiredAPI) \  
private: \  
    TClass& operator=(TClass&&);   \  
    TClass& operator=(const TClass&);   \  
public: \  
    typedef TSuperClass Super;\  
    typedef TClass ThisClass;\  
    TClass(EInternal InInernal, FFieldClass* InClass) \  
       : Super(EC_InternalUseOnlyConstructor, InClass) \  
    { \  
    } \  
    static TRequiredAPI FFieldClass* StaticClass(); \  
    static FField* Construct(const FFieldVariant& InOwner, const FName& InName, EObjectFlags InObjectFlags); \  
    inline static constexpr uint64 StaticClassCastFlagsPrivate() \  
    { \  
       return uint64(TStaticFlags); \  
    } \  
    inline static constexpr uint64 StaticClassCastFlags() \  
    { \  
       return uint64(TStaticFlags) | Super::StaticClassCastFlags(); \  
    } \  
    inline void* operator new(const size_t InSize, void* InMem) \  
    { \  
       return InMem; \  
    } \  
    inline void* operator new(const size_t InSize) \  
    { \  
       DECLARE_FIELD_NEW_IMPLEMENTATION(TClass) \  
    } \  
    inline void operator delete(void* InMem) noexcept \  
    { \  
       FMemory::Free(InMem); \  
    } \  
    friend FArchive &operator<<( FArchive& Ar, ThisClass*& Res ) \  
    { \  
       return Ar << (FField*&)Res; \  
    } \  
    friend void operator<<(FStructuredArchive::FSlot InSlot, ThisClass*& Res) \  
    { \  
       InSlot << (FField*&)Res; \  
    }  
  
#if !CHECK_PUREVIRTUALS  
    #define IMPLEMENT_FIELD_CONSTRUCT_IMPLEMENTATION(TClass) \  
       FField* Instance = new TClass(InOwner, InName, InFlags); \  
       return Instance; #else  
    #define IMPLEMENT_FIELD_CONSTRUCT_IMPLEMENTATION(TClass) \  
       return nullptr;  
#endif
```

It's no surprise that this looks exactly like the `DECLARE_CLASS` macro. `FField` is a mirror image of the UObject, except it reflects data objects. Just like in UClass calling `GetPrivateStaticClass()`, `FField` has its own version defined in its CPP file with `IMPLEMENT_FIELD`.

```c
#define IMPLEMENT_FIELD(TClass) \  
FField* TClass::Construct(const FFieldVariant& InOwner, const FName& InName, EObjectFlags InFlags) \  
{ \  
    IMPLEMENT_FIELD_CONSTRUCT_IMPLEMENTATION(TClass) \  
} \  
FFieldClass* TClass::StaticClass() \  
{ \  
    static FFieldClass StaticFieldClass(TEXT(#TClass), TClass::StaticClassCastFlagsPrivate(), TClass::StaticClassCastFlags(), TClass::Super::StaticClass(), &TClass::Construct); \  
    return &StaticFieldClass; \  
} \
```

The construction of FFloatProperty goes through a deep super call templated constructor chain.

![[Reflection Diagrams/FPropertyConstruction.png]](https://github.com/staticJPL/Unreal-Engine-Documentation/blob/b25a89365da6488452f86647f52b88fbf9c7cfe9/Unreal%20Engine%20Reflection%20System/Reflection%20Diagrams/FPropertyConstruction.png)

The intermediate layers of inheritance can be a bit confusing. TProperty_Numeric is the layer that converts the native CPP type and sets it inside a struct container. The next layer is TProperty_WithEqualityAndSerializer, which is used to provide internal serialization helper functions. Finally, the templated TProperty calls the FProperty constructor.

```cpp
FProperty::FProperty(FFieldVariant InOwner, const UECodeGen_Private::FPropertyParamsBaseWithOffset& Prop, EPropertyFlags AdditionalPropertyFlags /*= CPF_None*/)  
    : FField(InOwner, UTF8_TO_TCHAR(Prop.NameUTF8), Prop.ObjectFlags)  
    , ArrayDim(1)  
    , ElementSize(0)  
    , PropertyFlags(Prop.PropertyFlags | AdditionalPropertyFlags)  
    , RepIndex(0)  
    , BlueprintReplicationCondition(COND_None)  
    , Offset_Internal(0)  
    , PropertyLinkNext(nullptr)  
    , NextRef(nullptr)  
    , DestructorLinkNext(nullptr)  
    , PostConstructLinkNext(nullptr)  
{  
    this->Offset_Internal = Prop.Offset;  
  
    Init();  
}
```

#### UScriptStruct & CPPStructOps

Recall that UScriptStruct is used as a POD. In the previous section, the construction of property types used to aggregate into a struct is collected together through ReturnStructParams. However, another interesting templated system is introduced.

```cpp
#define UE_IMPLEMENT_STRUCT(PackageNameText, BaseName) \  
    static UScriptStruct::TAutoCppStructOps<F##BaseName> BaseName##_Ops(FTopLevelAssetPath(TEXT(PackageNameText), TEXT(#BaseName)));
```

This macro ends up breaking down into

```cpp
/** Template for noexport classes to autoregister before main starts **/  
template<class CPPSTRUCT>  
struct TAutoCppStructOps  
{  
TAutoCppStructOps(FTopLevelAssetPath InName)  
{       
	DeferCppStructOps(InName,new TCppStructOps<CPPSTRUCT>);  
}};
```

The key thing to see here is the DeferCppStructOps call

```cpp
/** Stash a CppStructOps for future use   
* @param Target Name of the struct* @param InCppStructOps Cpp ops for this struct**/  
void UScriptStruct::DeferCppStructOps(FTopLevelAssetPath Target, ICppStructOps* InCppStructOps)  
{  
    TMap<FTopLevelAssetPath, UScriptStruct::ICppStructOps*>& DeferredStructOps = GetDeferredCppStructOps();  
  
    if (UScriptStruct::ICppStructOps* ExistingOps = DeferredStructOps.FindRef(Target))  
    {       IReload* Reload = GetActiveReloadInterface();  
       if (Reload == nullptr)  
       {          check(ExistingOps != InCppStructOps); // if it was equal, then we would be re-adding a now stale pointer to the map  
          delete ExistingOps;  
       }       
       else if (!Reload->GetEnableReinstancing(false))  
       {          
	       delete InCppStructOps;  
	       return;  
       }       // in reload, we will just leak these...they may be in use.  
    }  
    DeferredStructOps.Add(Target, InCppStructOps);  
}
```

DeferCppStructOps is the collection entry point for our type information. In a sense, this is where native types are wrapped. In the Engine source, Property.cpp, TStructOpsTypeTraits is declared.

```cpp
template<typename T>  
struct TIntPointStructOpsTypeTraits : public TStructOpsTypeTraitsBase2<T>  
{  
	enum   
	{  
	   WithIdenticalViaEquality = true,  
	   WithNoInitConstructor = true,  
	   WithZeroConstructor = true,  
	   WithSerializer = true,  
	   WithSerializeFromMismatchedTag = true,  
	}; 
static constexpr EPropertyObjectReferenceType WithSerializerObjectReferences = EPropertyObjectReferenceType::None;  
};  
template<> struct TStructOpsTypeTraits<FInt32Point> : public TIntPointStructOpsTypeTraits<FInt32Point> {};  
template<> struct TStructOpsTypeTraits<FInt64Point> : public TIntPointStructOpsTypeTraits<FInt64Point> {};  
template<> struct TStructOpsTypeTraits<FUint32Point> : public TIntPointStructOpsTypeTraits<FUint32Point> {};  
template<> struct TStructOpsTypeTraits<FUint64Point> : public TIntPointStructOpsTypeTraits<FUint64Point> {};  
UE_IMPLEMENT_STRUCT("/Script/CoreUObject", Int32Point);  
UE_IMPLEMENT_STRUCT("/Script/CoreUObject", Int64Point);  
UE_IMPLEMENT_STRUCT("/Script/CoreUObject", Uint32Point);  
UE_IMPLEMENT_STRUCT("/Script/CoreUObject", Uint64Point);  
UE_IMPLEMENT_STRUCT("/Script/CoreUObject", IntPoint);      // Aliased  
UE_IMPLEMENT_STRUCT("/Script/CoreUObject", UintPoint);     // Aliased
...
```

The template magic here is used to perform a "compile-time" system to collect some public functions used for the construction and destruction of the structs. These public functions are constructed at the beginning of the program. This is accomplished through the ICPPStructOps Interface and TCppStructOps, which implements that interface. The code below is what was inserted by the generated code to define the function to construct these public functions.

```cpp
void* Z_Construct_UScriptStruct_FMyStruct_Statics::NewStructOps()  
{       
	return (UScriptStruct::ICppStructOps*) new UScriptStruct::TCppStructOps<FMyStruct>();  
}
```

  
The use of ICppStructOps and TCppStructOps follows a visitor design pattern where, at compile time, they decouple the data structures and functions operating on the data structure.

For UStruct, there are public functions and virtual functions for ICppStructOps. Hence, the struct can be operated upon through these functions without knowing its exact type at compile time.

```cpp
new UScriptStruct::TCppStructOps<FMyStruct>
```

The template sets up the public functions to add to DeferredStructOps. For UScriptStruct, this is achieved through our module UPackage during the pre-registration and creation of the inner singleton. Some examples include the default constructor, set attribute size, memory and alignment, flags, etc.

These fields store different C++ features of the struct, such as whether there is a serialization function, assignment function, or zero constructor.

According to Dazhao:

"*Some C++ structure information cannot be detected through templates, so we need to manually mark it.*'"

This is actually done here 
```cpp
** type traits to cover the custom aspects of a script struct **/  
template <class CPPSTRUCT>  
struct TStructOpsTypeTraitsBase2  
{  
    enum  
    {  
       WithZeroConstructor            = false,                         // struct can be constructed as a valid object by filling its memory footprint with zeroes.  
       WithNoInitConstructor          = false,                         // struct has a constructor which takes an EForceInit parameter which will force the constructor to perform initialization, where the default constructor performs 'uninitialization'.  
       WithNoDestructor               = false,                         // struct will not have its destructor called when it is destroyed.  
       WithCopy                       = !TIsPODType<CPPSTRUCT>::Value, // struct can be copied via its copy assignment operator.  
       WithIdenticalViaEquality       = false,                         // struct can be compared via its operator==.  This should be mutually exclusive with WithIdentical.  
       WithIdentical                  = false,                         // struct can be compared via an Identical(const T* Other, uint32 PortFlags) function.  This should be mutually exclusive with WithIdenticalViaEquality.  
       WithExportTextItem             = false,                         // struct has an ExportTextItem function used to serialize its state into a string.  
       WithImportTextItem             = false,                         // struct has an ImportTextItem function used to deserialize a string into an object of that class.  
       WithAddStructReferencedObjects = false,                         // struct has an AddStructReferencedObjects function which allows it to add references to the garbage collector.  
       WithSerializer                 = false,                         // struct has a Serialize function for serializing its state to an FArchive.  
       WithStructuredSerializer       = false,                         // struct has a Serialize function for serializing its state to an FStructuredArchive.  
       WithPostSerialize              = false,                         // struct has a PostSerialize function which is called after it is serialized  
       WithNetSerializer              = false,                         // struct has a NetSerialize function for serializing its state to an FArchive used for network replication.  
       WithNetDeltaSerializer         = false,                         // struct has a NetDeltaSerialize function for serializing differences in state from a previous NetSerialize operation.  
       WithSerializeFromMismatchedTag = false,                         // struct has a SerializeFromMismatchedTag function for converting from other property tags.  
       WithStructuredSerializeFromMismatchedTag = false,               // struct has an FStructuredArchive-based SerializeFromMismatchedTag function for converting from other property tags.  
       WithPostScriptConstruct        = false,                         // struct has a PostScriptConstruct function which is called after it is constructed in blueprints  
       WithNetSharedSerialization     = false,                         // struct has a NetSerialize function that does not require the package map to serialize its state.  
       WithGetPreloadDependencies     = false,                         // struct has a GetPreloadDependencies function to return all objects that will be Preload()ed when the struct is serialized at load time.  
       WithPureVirtual                = false,                         // struct has PURE_VIRTUAL functions and cannot be constructed when CHECK_PUREVIRTUALS is true  
       WithFindInnerPropertyInstance  = false,                      // struct has a FindInnerPropertyInstance function that can provide an FProperty and data pointer when given a property FName  
       WithCanEditChange           = false,                      // struct has an editor-only CanEditChange function that can conditionally make child properties read-only in the details panel (same idea as UObject::CanEditChange)  
    };  
  
    static constexpr EPropertyObjectReferenceType WithSerializerObjectReferences = EPropertyObjectReferenceType::Conservative; // struct's Serialize method(s) may serialize object references of these types - default Conservative means unknown and object reference collector archives should serialize this struct };
```

This knowledge is powerful because you can observe the utilization of this system for various purposes such as Net Core, network serialization, mass, and many other functionalities. Here is a simple example inside the Online Framework to enable fast TArray replication.

```cpp
/** Specified to allow fast TArray replication */  
template<>  
struct TStructOpsTypeTraits<FLobbyPlayerStateInfoArray> : public TStructOpsTypeTraitsBase2<FLobbyPlayerStateInfoArray>  
{  
    enum  
    {  
       WithNetDeltaSerializer = true,  
    };
};
``` 

Setting the enum "WithNetDeltaSerializer" changes the way FLobbyPlayerStateInfoArray struct is created.

```cpp
/** Implement support for fast TArray replication */  
bool NetDeltaSerialize(FNetDeltaSerializeInfo & DeltaParms)  
{  
    return FFastArraySerializer::FastArrayDeltaSerialize<FLobbyPlayerStateActorInfo, FLobbyPlayerStateInfoArray>(Players, DeltaParms, *this);  
}
```


###### Static Collection Phase

![[Unreal Engine Reflection System/Reflection Diagrams/UStructUEnum.svg]](https://github.com/staticJPL/Unreal-Engine-Documentation/blob/b25a89365da6488452f86647f52b88fbf9c7cfe9/Unreal%20Engine%20Reflection%20System/Reflection%20Diagrams/UStructUEnum.svg)

**UStruct**

1. Declarations for the Struct Z_Construct_FMyStruct_Statics are generated by UHT and inserted.
2. Struct_MetaDataParams and NewProp_Score_MetaData are collected for Editor information.
3. NewProp_Score collects literal strings, metadata, and EPropertyGenFlags.
4. Collect all properties inserted from UHT into the PropPointers[] array.
5. ReturnStructParams collects the Outer UPackage information, the NewStructOps function pointer, PropPointers objects, and Metadata Params.
6. Z_Construct_UScriptStruct_FMyStruct() receives the ReturnStructParams to be passed into UECodeGen_Private::ContructUScriptStruct and returns an Inner Singleton set for FStructRegistrationInfo during static Pre-registration.
7. GetStaticStruct is called, taking UPackage and UScriptStruct Function Pointer as parameters and returning the Outer Singleton.

###### Static Pre-Registration

1. Inner and Outer Singletons are finally set in ScriptStructInfo[].
2. ScriptStructInfo[] contains the StaticStruct(), string name literal, NewStructOps constructor, and the StructRegistrationInfo.
3. Lastly, all of this is passed into the CompiledInDefer and forwarded to the StructDeferredRegistry.

#### Summary

The collection of UStruct first involves the creation of its atomic types. It starts with the collection of the information for each attribute into the `PropPointers`Array to be merged with the data in the structure. ConstructUScriptStruct constructs the Inner Singleton. The Struct parameters start with an `FPropertyParamsBase` memory layout as the struct base for casting struct polymorphism. The initialization list `={}` is used for simplicity to set these parameters. Since FPropertyParams is a POD, if the memory layout is consistent and guaranteed, then it can be correctly converted to any other structure using type pointers. In addition, TCppStructOps is used to set up the native struct functionality at compile time. After the necessary data is collected, it's sent off for Deferred Registration.

### UEnum Collection

###### Static Collection Phase

The static collection and creation of UEnum are the same as UStruct, where UEnum doesn't need any extra generation or collection required as a base class that UStruct provides for objects like UClass and UFunction.

**UEnum**
1. Struct Z_Construct_FEnum_Statics declarations are generated by UHT and inserted.
2. Enum_MetaDataParams and Enumerators[] arrays are filled with the integer type and a string information that it's associated with.
3. Enum Params collect the Z_Construct function pointer for UPackage, the Enumerators array, ECPPForm which defines how the C++ enum is declared, and the MetaData used in the editor.
4. GetStaticEnum is called to set up the OuterSingleton.

###### Static Pre-Registration

1. UECodeGen_Private::ConstructUEnum sets up the Inner Singleton using the Enum Params.
2. FEnumRegistrationInfo is collected into the defined Struct Z_CompiledinDeferFile EnumInfo[].
3. EnumInfo[] contains the StaticEnum function pointer, the string literal name, and the address of Z_Registration_Info_UEnum that comes from the IMPLEMENT_CORE_INTRINSIC_CLASS macro (Since it's still reflected but not UClass).
4. CompiledInDefer forwards arguments of the EnumInfo data to FEnumDeferredRegistry.

### UPackage Collection

![[Reflection Diagrams/UPackage.svg]](https://github.com/staticJPL/Unreal-Engine-Documentation/blob/b25a89365da6488452f86647f52b88fbf9c7cfe9/Unreal%20Engine%20Reflection%20System/Reflection%20Diagrams/UPackage.svg)
###### Static Collection Phase

The collection phase for the UPackage is the most straightforward. If the OuterSingleton is not constructed, the PackageParams inserted by UHT sets the reference of the module placed in "/Script/ReflectionTest". Module rules will be expanded in the Registration Phase, but we know that UPackage must be constructed first since it's the Outer Owner Reference for all the types defined in it. The function Pointer Z_Construct_UPackage__Script_ReflectionTest() will be collected alongside FPackageRegistrationInfo holding the Inner and Outer Singletons. This all gets passed down to Deferred Registration with CompiledInDeferFile.

###### Static Pre-Registration Phase

Once the UPackage is forwarded to FPackageDeferredRegistry, the dependent singletons for UClass and UInterface have a function pointer to call, and the Native types UEnum and UStruct use it to get a reference to the OuterSingleton of UPackage.

#### Summary 

To conclude, UHT inserts static types to collect type information during static initialization. The UECodeGen_Private namespace encapsulates this logic, containing data structures and constructors used for registration. When the module is processed, all the collected type information is passed to the templated Deferred Registry during the pre-registration phase.
