#### Final Summary

Unreal Engine's unique construction and initialization process of objects follows many layers of abstraction, starting with the early stages of the Reflection system. UHT generates C++ code needed to capture all the types marked with `UClass`. The macros `IMPLEMENT_CLASS` and `DECLARE_CLASS` define boilerplate code needed for `StaticClass()` to construct a `UClass`.

During `Preinit()` at editor startup, the `CoreUObject` module is loaded first, and `StartupModule` binds delegates used by `ProcessNewlyLoadedObjects` to be notified when to process/register `UClass` objects loaded after `CoreUObject` is fully initialized. The allocation and construction of the first `UObject` begins in the Registration phase. `UClassRegisterAllCompiledInClasses` retrieves the statically allocated Class Registry to process all `UClasses`, starting with native types (UClass, UStruct, etc.). Function pointers set forth by the reflection system are called, and `StaticClass()` begins the construction process for an object. Inside `GetPrivateStaticClassBody()`, `GUObjectAllocator` calls `AllocatedUObject` to preallocate the `UClass` using `placement new` and sets aside a memory block with the appropriate alignment for `UObjectBase`.

Once the `UClass` layout is allocated, the `UObject` initialization begins. In the case of `UObject`, its `Outer` package is constructed first using `NewObject` to create a transient package. This is part of the early construction process of `UObject` to set up the garbage collector and allocate the global object memory pool. After `UObjectBaseInit` is called, the `UObject` system is deemed initialized. Next, the pending registrant linked list is traversed by `UObjectProcessRegistrant` to force registration of the objects by calling `DeferredRegister`. `DeferredRegister` creates the outer package and hashes the `UObject` for later access.

`NewObject` is Unreal's method of constructing objects in a ubiquitous fashion. It introduces two key functions: `StaticConstructObject_Internal` and `StaticAllocateObject`. `StaticConstructObject_Internal` calls the templated default constructor of `UClass`, wrapped inside `InternalConstructor`. `InternalConstructor` is ultimately aliased to `ClassConstructorType` as a function pointer, assigned to the `ClassConstructor` member variable of `UClass`. The `DefaultConstructor` can be invoked with or without an initializer passed into the constructed `UClass`. Before construction sets any initial values, `StaticAllocateObject` determines whether there are any old objects that can be recycled. If the object exists, the already allocated memory block at that address is reused; otherwise, a new block is allocated. The `NewObject` process is called twice, each time invoking different overloaded versions of the constructor. The `UObject` created is added to the global object array pool, and the second invocation calls the parent class constructor.

After the `UObject` system is initialized, the remaining class objects loaded from additional modules are constructed inside `ProcessNewlyLoadedObjects`. In the final stages of `UClass` construction, the CDO `Template` object is created with a `GetDefaultObject()` function call and is referenced inside the `UClass`. The CDO represents a `Template` object that defines the default state for all instances created with `NewObject`. The template object follows the Prototype design pattern; this special object is used in different initialization and construction scenarios, allowing runtime instancing while enabling customization of the construction process.

The `Template` object is often misunderstood and isn't always a CDO object. A templated object can be an archetype loaded from disk or even a custom instanced object provided by the user, which can override the CDO as the primary template object in the initialization process.

The last sections cover the initialization system. `FProperty`, `FObjectInitializer`, and `Serialization` work together to emulate the Builder design pattern. `FObjectInitializer` is an instantiated object parameter used to perform custom construction and initialization.

Property initialization logic is part of the `FObjectInitializer` lifecycle. It begins when an object constructor gets a `ThreadContext` singleton to access an initializer stack stored in thread-specific memory. The Initializer objects are pushed onto the initializer stack to cache the order of constructor calls made from the most derived class all the way up to the base, including any nested default sub-objects contained within that object. Upon destruction of the initializer object, post-initialization logic starts processing object properties recursively until all Initializers are popped off the initializer stack.

Due to the complexity of initializing many `UPROPERTY` types within a class or structure, the traversal and processing of these properties can be slow and cumbersome. Therefore, `UProperty` was refactored from `UObject` and redesigned into `FProperty` to optimize overall performance.

The property initialization system relies on the setup and creation of `FProperty` types. The creation starts with the Unreal Header Tool parsing property macros into generated code. The generated code collects the property types into an array of `PropPointers`. These `PropPointers` are `FPropertyParamsBase` types that later become type-casted to the appropriate `FProperty` during construction. The construction code is defined inside the `DECLARE_FIELD` macro, similar to the `DECLARE_CLASS` macro.

`FField` and `FFieldClass` expose reflection functionality used by the initialization system to traverse `FProperties` aggregated within `UStruct`. Furthermore, `Serialization` links the `UStruct` with an `FArchive` wrapper to fix up any object references and set memory offsets for each property. This step assigns the correct references to pointers: `PropertyLinkPtr`, `DestructorLinkPtr`, `RefLinkPtr`, and `PostConstructLinkPtr`. These pointers are tied to a set of linked lists that hold the order of derived properties, object references, destruction, and properties requiring post-initialization after construction. These linked lists are integral to the initialization process.

`Serialization` is also involved in property initialization during the saving or loading of assets from disk. `Tofu Theory` describes the basics of a serialization system, where an interpretable format can be deduced by slicing a byte array into sections. This format is later interpreted to determine how to load the data and their types back to their original state on any target machine. However, creating a byte array format is not straightforward for Unreal's `FProperty` and `UObject` types. To address this, Unreal uses two different serialization methods: `TaggedPropertySerializer` and `UnversionedPropertySerializer` are header formats used to tag serialized properties. When `FPropertyTags` are extracted during deserialization, the `UClass` is searched based on that tag information so the initialization process can map the data object back into memory.

To customize the serialization of object types, `FArchive` acts as a visitor interface that passes through the virtual function `void Serialize(FArchive& Ar)`. Following the Visitor Pattern, `FArchive` traverses a complex object tree to apply different types of serialization methods. `UObject` serialization depends on the `FArchive` passed. Ultimately, the order of serialization follows the outer relationship of an object's hierarchy; this is crucial when an object is initialized and re-instanced with `NewObject` into memory. During deserialization of object instances, determining pointer references between other objects can be challenging to recreate correctly into memory. This is addressed by `Pointer Swizzling`, with unique `Virtual Paths` generated by the engine. `UAssets` contain `Export` and `Import` tables that map these `Virtual Paths`. These tables recreate the reference relationship between the object contained in the package (Export) and the information of the class objects references (Import) back into memory. Usually, this involves reconstruction and initialization of loaded objects unless they're found in memory with their `UClass` information. If no such object exists in memory, then the construction of a dummy object is performed. Post-construction initialization begins, traversing `FProperties` and setting default values for native types and instancing any sub-objects recursively with their template objects.

Therefore, when creating a new object—whether deserializing a newly loaded object, duplicating, modifying, or re-instancing an object in the editor—the instantiation process performs shallow or deep copy (recursively) with the object initializer passed to the main object constructor inside `StaticConstructObject_Internal`. The construction of sub-object attributes can be complex when dealing with a main object that contains sub-object components. These sub-objects can have their own deep inheritance hierarchy and contain their own instanced sub-objects. The `FObjectInitializer` stack is used to cache this recursive process.

When post-initializing sub-object components, both the main object and sub-objects are added to an `FObjectInstancingGraph`. The `FObjectInstancingGraph` is a hashmap that holds a key-value pair between the template object and its instance. The `FObjectInstancingGraph` is traversed based on the references stored inside the `ComponentInits` list; this is where each sub-object added has post-initialization work done. To clarify, the `FObjectInstancingGraph` isn't just used to hold references for specific sub-objects that require custom post-initialization. The data structure is built to define a main object's template objects and its instanced objects, ensuring correct deep copies of objects.

Instantiation of all sub-objects starts inside `PostConstructInit`. The `InstanceSubobjectTemplates` is a member function of `UStruct` called upon to traverse all `UClass` properties defined by the main object and the sub-objects. `FProperty` has its own version of `InstanceSubObjects`, which is called to instantiate itself for each property. The `FProperty` type `FObjectPropertyBase` is the base class for a `UObject` type. It contains a virtual function where derived properties can override how to instantiate themselves when called. Finally, when `InstanceSubobject` is called on the property, it attempts to read the value for the property in the current object by calling `InstanceGraph` `InstancePropertyValue`. Once instantiated, it writes the value back. It's apparent that this instantiation logic is encapsulated within the instance graph. This continues to follow the Builder design pattern. Lastly, `GetInstanceSubObject` gets `MaybeNewValue`. This is the last step in the instantiation process of a sub-object, where the state of the variable may change in different scenarios before assigning the actual value. If the sub-object is not found, it will instantiate a new one.

Unreal Engine has to deal with many different construction scenarios, and it does its best to not overcomplicate the creation of nested objects. While no system is perfect, the system does a great job of covering most construction scenarios a programmer may encounter.